package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"regexp"
	"strings"

	// Generated files - mandatory for custom options.
	option "github.com/geomodular/meta-store/gen/ai/h2o/meta_store"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	filename := file.GeneratedFilenamePrefix + ".pb.meta.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-meta. DO NOT EDIT!!!")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, msg := range file.Messages {
		options := msg.Desc.Options().(*descriptorpb.MessageOptions)
		// NOTE: To load extension ahead check: https://github.com/golang/protobuf/issues/1260
		ext := proto.GetExtension(options, option.E_CollectionType).(option.CollectionType)

		if ext == option.CollectionType_DOCUMENT {
			g.P("// Meta", msg.GoIdent, " is a DOCUMENT type collection.")
		} else if ext == option.CollectionType_EDGE {
			g.P("// Meta", msg.GoIdent, " is an EDGE type collection.")
		}

		g.P("type Meta", msg.GoIdent, " struct {")
		g.P()
		g.P("// Mandatory `key` field.")
		g.P("Key string `json:\"_key,omitempty\"`")
		g.P()
		g.P("// Other fields.")
		for _, field := range msg.Fields {
			t, p := fieldGoType(g, field)
			if p {
				g.P(field.GoName, " *", t, " `json:\"", toArangoIdent(field.GoName), "\"`")
			} else {
				g.P(field.GoName, " ", t, " `json:\"", toArangoIdent(field.GoName), "\"`")
			}
		}
		g.P("}")
		g.P()
		g.P("func (m *Meta", msg.GoIdent, ") ToProto() *", msg.GoIdent, "{")
		g.P("return &", msg.GoIdent, "{")
		for _, field := range msg.Fields {
			t, _ := fieldGoType(g, field)
			switch t {
			case "time.Time":
				g.QualifiedGoIdent(protogen.GoIdent{"", "github.com/geomodular/meta-store/pkg/utils"})
				g.P(field.GoName, ": utils.ToProtoTimestamp(m.", field.GoName, "),")
			default:
				g.P(field.GoName, ": m.", field.GoName, ",")
			}
		}
		g.P("}")
		g.P("}")
		g.P()
		g.P("func NewMeta", msg.GoIdent, "FromProto(dataset *", msg.GoIdent, ") *Meta", msg.GoIdent, "{")
		g.P("return &Meta", msg.GoIdent, "{")
		g.P("Key: \"\",")
		for _, field := range msg.Fields {
			t, _ := fieldGoType(g, field)
			switch t {
			case "time.Time":
				g.QualifiedGoIdent(protogen.GoIdent{"", "github.com/geomodular/meta-store/pkg/utils"})
				g.P(field.GoName, ": utils.FromProtoTimestamp(dataset.", field.GoName, "),")
			default:
				g.P(field.GoName, ": dataset.", field.GoName, ",")
			}
		}
		g.P("}")
		g.P("}")
	}

	return g
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

// https://stackoverflow.com/questions/56616196/how-to-convert-camel-case-string-to-snake-case
func toSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

func toArangoIdent(name string) string {
	snake := toSnakeCase(name)
	return strings.ToLower(snake)
}

func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind:
		if field.Message.GoIdent.GoName == "Timestamp" {
			g.QualifiedGoIdent(protogen.GoIdent{"", "time"})
			goType = "time.Time"
		} else {
			goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		}
		pointer = false
	case protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}

	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}

	return goType, pointer
}
